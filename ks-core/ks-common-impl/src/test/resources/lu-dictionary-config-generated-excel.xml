<?xml version="1.0" encoding="UTF-8"?>
<!--

    Copyright 2010 The Kuali Foundation Licensed under the
    Educational Community License, Version 2.0 (the "License"); you may
    not use this file except in compliance with the License. You may
    obtain a copy of the License at

    http://www.osedu.org/licenses/ECL-2.0

    Unless required by applicable law or agreed to in writing,
    software distributed under the License is distributed on an "AS IS"
    BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
    or implied. See the License for the specific language governing
    permissions and limitations under the License.

-->

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dict="http://student.kuali.org/xsd/dictionary-extension"
	xsi:schemaLocation="
http://student.kuali.org/xsd/dictionary-extension http://student.kuali.org/xsd/dictionary-extension/dictionary-extension.xsd
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
">
	<!-- Added these constrains because they were referenced by other beans but did not exist-->
	<dict:constraint key="calculated" id="calculated">
	</dict:constraint>
	
	<dict:constraint key="repeating" id="repeating">
	</dict:constraint>
	
	<dict:constraint key="hard.coded.official" id="hard.coded.official">
	</dict:constraint>

	<dict:constraint key="hard.coded.active" id="hard.coded.active">
	</dict:constraint>

	<dict:constraint key="hard.coded.cross-listed" id="hard.coded.cross-listed">
	</dict:constraint>

	<dict:constraint key="hard.coded.version" id="hard.coded.version">
	</dict:constraint>
	<!--  End  -->
	
		
	<dict:constraint key="required" id="required">
		<!-- Required -->
		<dict:minOccurs>1</dict:minOccurs>
	</dict:constraint>
	<dict:constraint key="optional" id="optional">
		<!-- Optional -->
		<!--
			Used to override a previous required constraint. Also implied by the
			absence of a required constraint
		-->
		<dict:minOccurs>0</dict:minOccurs>
	</dict:constraint>
	<dict:constraint key="not.used" id="not.used">
		<!-- Not Used -->
		<dict:minOccurs>0</dict:minOccurs>
		<dict:maxOccurs>0</dict:maxOccurs>
	</dict:constraint>
	<dict:constraint key="code" id="code">
		<!-- Alphanumeric code, hypen and period. -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:validChars>
			<dict:value>regex:[A-Za-z0-9.-]*</dict:value>
		</dict:validChars>
	</dict:constraint>
	<dict:constraint key="uppercase" id="uppercase">
		<!-- uppercase alphanumeric code, hypen and period. -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:validChars>
			<dict:value>regex:[A-Z0-9.-]*</dict:value>
		</dict:validChars>
	</dict:constraint>
	<dict:constraint key="lowercase" id="lowercase">
		<!-- lowercase alphanumeric code, hypen and period. -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:validChars>
			<dict:value>regex:[a-z0-9.-]*</dict:value>
		</dict:validChars>
	</dict:constraint>
	<dict:constraint key="free.text" id="free.text">
		<!--
			Free form text field; most characters allowed except carraige-return,
			line-feed, tabs, etc.
		-->
		<!-- What about international characters? -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>255</dict:maxLength>
		<dict:validChars>
			<dict:value><![CDATA[ regex:[A-Za-z0-9.-;;&apos;&amp;%$#@!]*]]></dict:value>
		</dict:validChars>
	</dict:constraint>
	<dict:constraint key="plain.text" id="plain.text">
		<!--
			Multi-line text field that accepts most standard characters plus
			carraige-return and linefeed.
		-->
		<dict:minLength>1</dict:minLength>
		<dict:validChars>
			<dict:value><![CDATA[regex:[A-Za-z0-9.-;;&apos;&amp;%$#@!\n\r\t]*]]></dict:value>
		</dict:validChars>
	</dict:constraint>
	<dict:constraint key="rich.text" id="rich.text">
		<!-- Multi-line text field that accepts all types of characters -->
		<!--
			Not sure rich text means we need to allow all types of characters
		-->
		<dict:minLength>1</dict:minLength>
	</dict:constraint>
	<dict:constraint key="date" id="date">
		<!-- Date -->
		<!-- http://regexlib.com/REDetails.aspx?regexp_id=760 (but not sure) -->
		<dict:minLength>10</dict:minLength>
		<dict:maxLength>10</dict:maxLength>
	</dict:constraint>
	<dict:constraint key="date.time" id="date.time">
		<!-- Date-Time -->
		<!--
			http://regexlib.com/REDetails.aspx?regexp_id=1966 (but not sure)
		-->
		<dict:minLength>19</dict:minLength>
		<dict:maxLength>19</dict:maxLength>
	</dict:constraint>
	<dict:constraint key="integer" id="integer">
		<!-- Integer -->
		<!-- http://regexlib.com/REDetails.aspx?regexp_id=14 -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>10</dict:maxLength>
		<dict:validChars>
			<dict:value>regex:^(\+|-)?\d+$</dict:value>
		</dict:validChars>
	</dict:constraint>
	<dict:constraint key="positive.integer" id="positive.integer">
		<!-- Positive Integer -->
		<!-- http://regexlib.com/REDetails.aspx?regexp_id=13 -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>10</dict:maxLength>
		<dict:validChars>
			<dict:value>regex:^\d+$</dict:value>
		</dict:validChars>
	</dict:constraint>
	<dict:constraint key="decimal" id="decimal">
		<!-- decimal number -->
		<!-- http://regexlib.com/REDetails.aspx?regexp_id=117 -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>10</dict:maxLength>
		<dict:validChars>
			<dict:value>regex:^[-+]?\d+(\.\d+)?$
			</dict:value>
		</dict:validChars>
	</dict:constraint>
	<dict:constraint key="amount" id="amount">
		<!-- Amount field -->
		<!-- http://regexlib.com/REDetails.aspx?regexp_id=131 -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>10</dict:maxLength>
		<dict:validChars>
			<dict:value>regex:^\$?\d+(\.(\d{2}))?$
			</dict:value>
		</dict:validChars>
	</dict:constraint>
	<dict:constraint key="kuali.id" id="kuali.id"
		serverSide="true">
		<!-- Kuali ID; calculated by service on add, then read-only. -->
		<dict:minOccurs>1</dict:minOccurs>
		<dict:maxOccurs>1</dict:maxOccurs>
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>36</dict:maxLength>
	</dict:constraint>
	<dict:constraint key="kuali.type" id="kuali.type"
		serverSide="true">
		<!-- Kuali TYPE: required on add, then read-only -->
		<dict:minOccurs>1</dict:minOccurs>
		<dict:maxOccurs>1</dict:maxOccurs>
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:validChars>
			<dict:value>regex:[A-Za-z0-9.-]*</dict:value>
		</dict:validChars>
	</dict:constraint>
	<dict:constraint key="kuali.state" id="kuali.state"
		serverSide="true">
		<!-- Kuali STATE: required -->
		<dict:minOccurs>1</dict:minOccurs>
		<dict:maxOccurs>1</dict:maxOccurs>
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>30</dict:maxLength>
		<dict:validChars>
			<dict:value>regex:[A-Za-z0-9.-]*</dict:value>
		</dict:validChars>
	</dict:constraint>
	<dict:constraint key="kuali.meta.data" id="kuali.meta.data"
		serverSide="true">
		<!-- Kuali Meta Data: calculated by service, read-only -->
		<dict:minOccurs>1</dict:minOccurs>
		<dict:maxOccurs>1</dict:maxOccurs>
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>36</dict:maxLength>
	</dict:constraint>
	<dict:constraint key="related.cluId" id="related.cluId"
		serverSide="true">
		<!-- Id of an existing CLU -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>36</dict:maxLength>
	</dict:constraint>
	<dict:constraint key="related.orgId" id="related.orgId"
		serverSide="true">
		<!-- Id of an existing ORG -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>36</dict:maxLength>
	</dict:constraint>
	<dict:constraint key="related.principalId" id="related.principalId"
		serverSide="true">
		<!-- Id of an existing PRINCIPAL -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>36</dict:maxLength>
	</dict:constraint>
	<dict:constraint key="lu.types" id="lu.types">
		<!-- In list of configured learning unit types -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.lu.types">
			<dict:lookupKey field="(none)" mapsTo="(none)" />
		</dict:lookup>
	</dict:constraint>
	<dict:constraint key="lu.identifier.types" id="lu.identifier.types">
		<!-- In list of configured clu identifier types -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.lu.identifier.types">
			<dict:lookupKey field="(none)" mapsTo="(none)" />
		</dict:lookup>
	</dict:constraint>
	<dict:constraint key="duration.types" id="duration.types">
		<!-- In list of configured duration types -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.durationTypes">
			<dict:lookupKey field="(none)" mapsTo="(none)" />
		</dict:lookup>
	</dict:constraint>
	<dict:constraint key="instructional.format.types" id="instructional.format.types">
		<!-- In list of configured instructional formats -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>30</dict:maxLength>
		<dict:lookup search="kuali.enum.type.instructionalFormatTypes">
			<dict:lookupKey field="(none)" mapsTo="(none)" />
		</dict:lookup>
	</dict:constraint>
	<dict:constraint key="season.types" id="season.types">
		<!-- In list of configured seasons -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.seasonTypes">
			<dict:lookupKey field="(none)" mapsTo="(none)" />
		</dict:lookup>
	</dict:constraint>
	<dict:constraint key="atp.types" id="atp.types">
		<!-- In list of configured  time period types -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.atpTypes">
			<dict:lookupKey field="(none)" mapsTo="(none)" />
		</dict:lookup>
	</dict:constraint>
	<dict:constraint key="dynamic.field.types" id="dynamic.field.types">
		<!-- In list of configured dynamic field types -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.dynamicFieldTypes">
			<dict:lookupKey field="(none)" mapsTo="(none)" />
		</dict:lookup>
	</dict:constraint>
	<dict:constraint key="clu.clu.relation.types" id="clu.clu.relation.types">
		<!-- In list of configured clul-clu relation types -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.clu.clu.relation.types">
			<dict:lookupKey field="(none)" mapsTo="(none)" />
		</dict:lookup>
	</dict:constraint>
	<dict:constraint key="lu.states" id="lu.states">
		<!-- In list of configured learning unit states -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>30</dict:maxLength>
		<dict:lookup search="kuali.enum.type.lu.states">
			<dict:lookupKey field="(none)" mapsTo="(none)" />
		</dict:lookup>
	</dict:constraint>
	<dict:constraint key="lu.identifier.states" id="lu.identifier.states">
		<!-- In list of configured clu identifier states -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>30</dict:maxLength>
		<dict:lookup search="kuali.enum.type.lu.identifier.states">
			<dict:lookupKey field="(none)" mapsTo="(none)" />
		</dict:lookup>
	</dict:constraint>
	<dict:constraint key="subject.area" id="subject.area">
		<!-- In list of configured subject areas -->
		<dict:minLength>4</dict:minLength>
		<dict:maxLength>4</dict:maxLength>
		<dict:validChars>
			<dict:value>regex:[A-Z]*</dict:value>
		</dict:validChars>
		<dict:lookup search="kuali.enum.type.subjectArea">
			<dict:lookupKey field="(none)" mapsTo="(none)" />
		</dict:lookup>
	</dict:constraint>
	<dict:constraint key="available.course.numbers" id="available.course.numbers">
		<!-- In list of configured available course numbers -->
		<dict:minLength>3</dict:minLength>
		<dict:maxLength>3</dict:maxLength>
		<dict:validChars>
			<dict:value>regex:[0-9]*</dict:value>
		</dict:validChars>
		<dict:lookup search="kuali.enum.type.availableNumbers">
			<dict:lookupKey field="(none)" mapsTo="(none)" />
		</dict:lookup>
	</dict:constraint>
	<dict:constraint key="offering.campuses" id="offering.campuses">
		<!-- In list of configured offering campuses -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>30</dict:maxLength>
		<dict:lookup search="kuali.enum.type.offeringCampuses">
			<dict:lookupKey field="(none)" mapsTo="(none)" />
		</dict:lookup>
	</dict:constraint>
	<dict:constraint key="unit.types" id="unit.types">
		<!-- In list of configured unit types -->
		<!--
			Although called a type, this is not a formal type in kuali student
			like an lu type, for example it may be changeable after being added.
		-->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>10</dict:maxLength>
		<dict:lookup search="kuali.enum.type.validUnitTypes">
			<dict:lookupKey field="(none)" mapsTo="(none)" />
		</dict:lookup>
	</dict:constraint>

	<dict:objectStructure key="cluInfo">
		<!-- Detailed information about a single CLU. -->
		<dict:type key="kuali.lu.type.CreditCourse">
			<!-- A course offered for academic credit -->
			<!-- Subject, Academic Course -->
			<dict:state key="template">
				<!--
					A template holds configuration for defaults for creating a new
					course
				-->
				<!--
					Not sure if this is needed but UC mentions some ability for
					professors to create proposals within their own space
				-->

				<dict:field id="course.no" key="officialIdentifier">
					<dict:fieldDescriptor>
						<dict:name>course.no</dict:name>
						<dict:desc>course no</dict:desc>
						<dict:dataType>complex</dict:dataType>

						<dict:objectStructure key="cluIdentifierInfo">
							<!--
								Detailed information about the human readable form of a CLU
								Identifier
							-->
							<dict:type key="kuali.lu.type.CreditCourse.identifier.official">
								<!-- This identifier holds the official identifier for this course -->
								<dict:state key="active">
									<!-- Identifier is active -->
									<!--
										TODO: Worry about states overlapping across xmlObjects. The
										lookup on thge Dictionary worksheet will grab the wrong one
									-->

									<dict:field id="course.official.no" key="code">
										<dict:fieldDescriptor>
											<dict:name>course.official.no</dict:name>
											<dict:desc>course number</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="code"/>
											<dict:constraintRef bean="calculated"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.official.transcriptTitle"
										key="shortName">
										<dict:fieldDescriptor>
											<dict:name>course.official.transcriptTitle</dict:name>
											<dict:desc>transcript title</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="free.text"/>
											<dict:constraintRef bean="required"/>

											<dict:constraint key="course.official.transcriptTitle">
												<dict:maxLength>20</dict:maxLength>
											</dict:constraint>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.official.catalogTitle" key="longName">
										<dict:fieldDescriptor>
											<dict:name>course.official.catalogTitle</dict:name>
											<dict:desc>catalog title</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="free.text"/>
											<dict:constraintRef bean="required"/>

											<dict:constraint key="course.official.catalogTitle">
												<dict:maxLength>60</dict:maxLength>
											</dict:constraint>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.official.level" key="level">
										<dict:fieldDescriptor>
											<dict:name>course.official.level</dict:name>
											<dict:desc>level</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="code"/>
											<dict:constraintRef bean="not.used"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.official.subjectArea" key="division">
										<dict:fieldDescriptor>
											<dict:name>course.official.subjectArea</dict:name>
											<dict:desc>subject area</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="code"/>
											<dict:constraintRef bean="required"/>
											<dict:constraintRef bean="subject.area"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.official.numberPart" key="suffixCode">
										<dict:fieldDescriptor>
											<dict:name>course.official.numberPart</dict:name>
											<dict:desc>number part of the course number</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="code"/>
											<dict:constraintRef bean="required"/>
											<dict:constraintRef bean="available.course.numbers"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.official.version" key="variation">
										<dict:fieldDescriptor>
											<dict:name>course.official.version</dict:name>
											<dict:desc>version code</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="code"/>
											<dict:constraintRef bean="not.used"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.official.adminOrg" key="orgId">
										<dict:fieldDescriptor>
											<dict:name>course.official.adminOrg</dict:name>
											<dict:desc>dept</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="related.orgId"/>
											<dict:constraintRef bean="not.used"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.official.type" key="type">
										<!-- Required when first adding but read-only thereafter -->
										<dict:fieldDescriptor>
											<dict:name>course.official.type</dict:name>
											<dict:desc>official</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="kuali.type"/>
											<dict:constraintRef bean="lu.identifier.types"/>
											<dict:constraintRef bean="hard.coded.official"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.official.state" key="state">
										<dict:fieldDescriptor>
											<dict:name>course.official.state</dict:name>
											<dict:desc>state</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="kuali.state"/>
											<dict:constraintRef bean="lu.identifier.states"/>
											<dict:constraintRef bean="hard.coded.active"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.official.internalId" key="id">
										<!--
											should be blank when first adding but required thereafter for
											updates
										-->
										<dict:fieldDescriptor>
											<dict:name>course.official.internalId</dict:name>
											<dict:desc>internal id of this id</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="kuali.id"/>
										</dict:constraintDescriptor>
									</dict:field>
								</dict:state>
								<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<dict:fieldRef bean="course.official.no"/>
									<dict:fieldRef bean="course.official.transcriptTitle"/>
									<dict:fieldRef bean="course.official.catalogTitle"/>
									<dict:fieldRef bean="course.official.level"/>
									<dict:fieldRef bean="course.official.subjectArea"/>
									<dict:fieldRef bean="course.official.numberPart"/>
									<dict:fieldRef bean="course.official.version"/>
									<dict:fieldRef bean="course.official.adminOrg"/>
									<dict:fieldRef bean="course.official.type"/>
									<dict:fieldRef bean="course.official.state"/>
									<dict:fieldRef bean="course.official.internalId"/>
								</dict:state>
							</dict:type>
							<dict:type key="kuali.lu.type.CreditCourse.identifier.cross-listed">
								<!--
									This identifier holds the cross-listed identifiers for this
									course
								-->
								<!-- (MIT's meaning of joint) -->
								<dict:state key="active">
									<!-- Identifier is active -->
									<!--
										TODO: Worry about states overlapping across xmlObjects. The
										lookup on thge Dictionary worksheet will grab the wrong one
									-->
								</dict:state>
								<dict:state key="inactive">
									<!-- Identifier is inactive -->
								</dict:state>
							</dict:type>
							<dict:type key="kuali.lu.type.CreditCourse.identifier.version">
								<!--
									This identifier holds the version information for courses that
									have multiple versions
								-->
								<!-- Variation -->
								<dict:state key="active">
									<!-- Identifier is active -->
									<!--
										TODO: Worry about states overlapping across xmlObjects. The
										lookup on thge Dictionary worksheet will grab the wrong one
									-->
								</dict:state>
								<dict:state key="inactive">
									<!-- Identifier is inactive -->
								</dict:state>
							</dict:type>
						</dict:objectStructure>
											<dict:search key="lalala"/>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.alternateIdentifiers" key="alternateIdentifiers">
					<dict:fieldDescriptor>
						<dict:name>course.alternateIdentifiers</dict:name>
						<dict:desc>course alternate ids</dict:desc>
						<dict:dataType>complex</dict:dataType>

						<dict:objectStructure key="cluIdentifierInfo">
							<!--
								Detailed information about the human readable form of a CLU
								Identifier
							-->
							<dict:type key="kuali.lu.type.CreditCourse.identifier.official">
								<!-- This identifier holds the official identifier for this course -->
								<dict:state key="active">
									<!-- Identifier is active -->
									<!--
										TODO: Worry about states overlapping across xmlObjects. The
										lookup on thge Dictionary worksheet will grab the wrong one
									-->
								</dict:state>
								<dict:state key="inactive">
									<!-- Identifier is inactive -->
								</dict:state>
							</dict:type>
							<dict:type key="kuali.lu.type.CreditCourse.identifier.cross-listed">
								<!--
									This identifier holds the cross-listed identifiers for this
									course
								-->
								<!-- (MIT's meaning of joint) -->
								<dict:state key="active">
									<!-- Identifier is active -->
									<!--
										TODO: Worry about states overlapping across xmlObjects. The
										lookup on thge Dictionary worksheet will grab the wrong one
									-->

									<dict:field id="course.cross-listed.no" key="code">
										<dict:fieldDescriptor>
											<dict:name>course.cross-listed.no</dict:name>
											<dict:desc>cross-listed number</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="code"/>
											<dict:constraintRef bean="calculated"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.cross-listed.transcriptTitle"
										key="shortName">
										<dict:fieldDescriptor>
											<dict:name>course.cross-listed.transcriptTitle</dict:name>
											<dict:desc>not used</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="free.text"/>
											<dict:constraintRef bean="not.used"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.cross-listed.catalogTitle"
										key="longName">
										<dict:fieldDescriptor>
											<dict:name>course.cross-listed.catalogTitle</dict:name>
											<dict:desc>not used</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="free.text"/>
											<dict:constraintRef bean="not.used"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.cross-listed.level" key="level">
										<dict:fieldDescriptor>
											<dict:name>course.cross-listed.level</dict:name>
											<dict:desc>not used</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="code"/>
											<dict:constraintRef bean="not.used"/>
										</dict:constraintDescriptor>
										<dict:dynamic>true</dict:dynamic>
									</dict:field>

									<dict:field id="course.cross-listed.subjectArea"
										key="division">
										<dict:fieldDescriptor>
											<dict:name>course.cross-listed.subjectArea</dict:name>
											<dict:desc>cross-listed subject area</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="code"/>
											<dict:constraintRef bean="required"/>
											<dict:constraintRef bean="subject.area"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.cross-listed.numberPart" key="suffixCode">
										<dict:fieldDescriptor>
											<dict:name>course.cross-listed.numberPart</dict:name>
											<dict:desc>number part of cross-listed number</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="code"/>
											<dict:constraintRef bean="required"/>
											<dict:constraintRef bean="available.course.numbers"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.cross-listed.version" key="variation">
										<dict:fieldDescriptor>
											<dict:name>course.cross-listed.version</dict:name>
											<dict:desc>not used</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="code"/>
											<dict:constraintRef bean="not.used"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.cross-listed.adminOrg" key="orgId">
										<dict:fieldDescriptor>
											<dict:name>course.cross-listed.adminOrg</dict:name>
											<dict:desc>cross-listed department</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="related.orgId"/>
											<dict:constraintRef bean="required"/>
											<dict:constraintRef bean="related.orgId"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.cross-listed.type" key="type">
										<!-- Required when first adding but read-only thereafter -->
										<dict:fieldDescriptor>
											<dict:name>course.cross-listed.type</dict:name>
											<dict:desc>cross-listed</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="kuali.type"/>
											<dict:constraintRef bean="lu.identifier.types"/>
											<dict:constraintRef bean="hard.coded.cross-listed"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.cross-listed.state" key="state">
										<dict:fieldDescriptor>
											<dict:name>course.cross-listed.state</dict:name>
											<dict:desc>state</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="kuali.state"/>
											<dict:constraintRef bean="lu.identifier.states"/>
											<dict:constraintRef bean="hard.coded.active"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.cross-listed.internalId" key="id">
										<!--
											should be blank when first adding but required thereafter for
											updates
										-->
										<dict:fieldDescriptor>
											<dict:name>course.cross-listed.internalId</dict:name>
											<dict:desc>internal id of cross-listed id</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="kuali.id"/>
										</dict:constraintDescriptor>
									</dict:field>
								</dict:state>
								<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<dict:fieldRef bean="course.cross-listed.no"/>
									<dict:fieldRef bean="course.cross-listed.transcriptTitle"/>
									<dict:fieldRef bean="course.cross-listed.catalogTitle"/>
									<dict:fieldRef bean="course.cross-listed.level"/>
									<dict:fieldRef bean="course.cross-listed.subjectArea"/>
									<dict:fieldRef bean="course.cross-listed.numberPart"/>
									<dict:fieldRef bean="course.cross-listed.version"/>
									<dict:fieldRef bean="course.cross-listed.adminOrg"/>
									<dict:fieldRef bean="course.cross-listed.type"/>
									<dict:fieldRef bean="course.cross-listed.state"/>
									<dict:fieldRef bean="course.cross-listed.internalId"/>
								</dict:state>
							</dict:type>
							<dict:type key="kuali.lu.type.CreditCourse.identifier.version">
								<!--
									This identifier holds the version information for courses that
									have multiple versions
								-->
								<!-- Variation -->
								<dict:state key="active">
									<!-- Identifier is active -->
									<!--
										TODO: Worry about states overlapping across xmlObjects. The
										lookup on thge Dictionary worksheet will grab the wrong one
									-->

									<dict:field id="course.version.no" key="code">
										<!--
											calculated by concatenating the subjecare, numberPart and
											version code.
										-->
										<dict:fieldDescriptor>
											<dict:name>course.version.no</dict:name>
											<dict:desc>version number</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="code"/>
											<dict:constraintRef bean="calculated"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.version.transcriptTitle" key="shortName">
										<dict:fieldDescriptor>
											<dict:name>course.version.transcriptTitle</dict:name>
											<dict:desc>not used</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="free.text"/>
											<dict:constraintRef bean="not.used"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.version.catalogTitle" key="longName">
										<!--
											Not sure this should actually be stored in the shortName
											field instead (or in-addition to) storing it in the longName
											field
										-->
										<dict:fieldDescriptor>
											<dict:name>course.version.catalogTitle</dict:name>
											<dict:desc>not used</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="free.text"/>
											<dict:constraintRef bean="required"/>

											<dict:constraint key="course.version.catalogTitle">
												<dict:maxLength>20</dict:maxLength>
											</dict:constraint>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.version.level" key="level">
										<dict:fieldDescriptor>
											<dict:name>course.version.level</dict:name>
											<dict:desc>not used</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="code"/>
											<dict:constraintRef bean="not.used"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.version.subjectArea" key="division">
										<!-- set to the official number's subjectArea -->
										<dict:fieldDescriptor>
											<dict:name>course.version.subjectArea</dict:name>
											<dict:desc>subject area</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="code"/>
											<dict:constraintRef bean="calculated"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.version.numberPart" key="suffixCode">
										<!-- set to the official number's numberPart -->
										<dict:fieldDescriptor>
											<dict:name>course.version.numberPart</dict:name>
											<dict:desc>number part of course number</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="code"/>
											<dict:constraintRef bean="calculated"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.version.version" key="variation">
										<dict:fieldDescriptor>
											<dict:name>course.version.version</dict:name>
											<dict:desc>version code</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="code"/>
											<dict:constraintRef bean="required"/>

											<dict:constraint key="course.version.version">
												<dict:maxLength>1</dict:maxLength>
												<dict:validChars>
													<dict:value>regex:[A-Z]</dict:value>
												</dict:validChars>
											</dict:constraint>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.version.adminOrg" key="orgId">
										<dict:fieldDescriptor>
											<dict:name>course.version.adminOrg</dict:name>
											<dict:desc>not used</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="related.orgId"/>
											<dict:constraintRef bean="not.used"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.version.type" key="type">
										<!-- Required when first adding but read-only thereafter -->
										<dict:fieldDescriptor>
											<dict:name>course.version.type</dict:name>
											<dict:desc>version</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="kuali.type"/>
											<dict:constraintRef bean="lu.identifier.types"/>
											<dict:constraintRef bean="hard.coded.version"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.version.state" key="state">
										<dict:fieldDescriptor>
											<dict:name>course.version.state</dict:name>
											<dict:desc>state</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="kuali.state"/>
											<dict:constraintRef bean="lu.identifier.states"/>
											<dict:constraintRef bean="hard.coded.active"/>
										</dict:constraintDescriptor>
									</dict:field>

									<dict:field id="course.version.internalId" key="id">
										<!--
											should be blank when first adding but required thereafter for
											updates
										-->
										<dict:fieldDescriptor>
											<dict:name>course.version.internalId</dict:name>
											<dict:desc>internal id of this course version</dict:desc>
											<dict:dataType>string</dict:dataType>
										</dict:fieldDescriptor>
										<dict:constraintDescriptor>
											<dict:constraintRef bean="kuali.id"/>
										</dict:constraintDescriptor>
									</dict:field>
								</dict:state>
								<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<dict:fieldRef bean="course.version.no"/>
									<dict:fieldRef bean="course.version.transcriptTitle"/>
									<dict:fieldRef bean="course.version.catalogTitle"/>
									<dict:fieldRef bean="course.version.level"/>
									<dict:fieldRef bean="course.version.subjectArea"/>
									<dict:fieldRef bean="course.version.numberPart"/>
									<dict:fieldRef bean="course.version.version"/>
									<dict:fieldRef bean="course.version.adminOrg"/>
									<dict:fieldRef bean="course.version.type"/>
									<dict:fieldRef bean="course.version.state"/>
									<dict:fieldRef bean="course.version.internalId"/>
								</dict:state>
							</dict:type>
						</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="repeating"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.campusLocation" key="campusLocationInfo">
					<!--
						The message structure goes to another substructure but that just
						holds a string so I don't thnk that is needed and I changed the
						name to "Info" instead of "List" which is on the un-needed
						sub-structure
					-->
					<dict:fieldDescriptor>
						<dict:name>course.campusLocation</dict:name>
						<dict:desc>campus location</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="repeating"/>
						<dict:constraintRef bean="code"/>
						<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>course.desc</dict:name>
						<dict:desc>dscription</dict:desc>
						<dict:dataType>complex</dict:dataType>

						<dict:objectStructure key="richTextInfo">
							<!--
								Complex type supporting both a plain text and formatted version
								of a string.
							-->
							<dict:type key="(n/a)">
								<!-- Not applicable -->
								<dict:state key="(n/a)">
									<!-- Not applicable -->
								</dict:state>
							</dict:type>
						</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.rationale" key="marketingDesc">
					<!--
						Not used in KRU but wanted an example of multiple RichText fields
					-->
					<!-- Rationale is stored in the Marketing Description for now -->
					<dict:fieldDescriptor>
						<dict:name>course.rationale</dict:name>
						<dict:desc>rationale</dict:desc>
						<dict:dataType>complex</dict:dataType>

						<dict:objectStructure key="richTextInfo">
							<!--
								Complex type supporting both a plain text and formatted version
								of a string.
							-->
							<dict:type key="(n/a)">
								<!-- Not applicable -->
								<dict:state key="(n/a)">
									<!-- Not applicable -->
								</dict:state>
							</dict:type>
						</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.primaryAdminOrg" key="primaryAdminOrg">
					<!--
						Services has this on it's own structure called AdminOrgInfo that
						allows for dynamic fields to be attached to the org but I am not
						modeling that right now so I don't have to go to 3 levels.
					-->
					<dict:fieldDescriptor>
						<dict:name>course.primaryAdminOrg</dict:name>
						<dict:desc>department</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="related.orgId"/>
						<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>

				<dict:field id="course.alternateAdminOrgs" key="alternateAdminOrgs">
					<!--
						Services has this on it's own structure called AdminOrgInfo that
						allows for dynamic fields to be attached to the org but I am not
						modeling that right now so I don't have to go to 3 levels.
					-->
					<dict:fieldDescriptor>
						<dict:name>course.alternateAdminOrgs</dict:name>
						<dict:desc>not used</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="repeating"/>
						<dict:constraintRef bean="related.orgId"/>
						<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>course.effectiveDate</dict:name>
						<dict:desc>first date can be offered</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="date"/>
						<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>course.expirationDate</dict:name>
						<dict:desc>last date can be offerred</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="date"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.contact.hours" key="intensity">
					<dict:fieldDescriptor>
						<dict:name>course.contact.hours</dict:name>
						<dict:desc>contact hours</dict:desc>
						<dict:dataType>complex</dict:dataType>

						<dict:objectStructure key="amountInfo">
							<!--
								Detailed information about an amount including both the type of
								units and the quantity.
							-->
							<dict:type key="(n/a)">
								<!-- Not applicable -->
								<dict:state key="(n/a)">
									<!-- Not applicable -->
								</dict:state>
							</dict:type>
						</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.duration" key="stdDuration">
					<dict:fieldDescriptor>
						<dict:name>course.duration</dict:name>
						<dict:desc>duration</dict:desc>
						<dict:dataType>complex</dict:dataType>

						<dict:objectStructure key="timeAmountInfo">
							<!--
								Detailed information about an amount of time including both the
								type of units and the quantity.
							-->
							<dict:type key="(n/a)">
								<!-- Not applicable -->
								<dict:state key="(n/a)">
									<!-- Not applicable -->
								</dict:state>
							</dict:type>
						</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.seasons" key="offeredAtpTypes">
					<!--
						Services has this as an atpKeyList but that is just a list of
						Strings so I didn't create the sub-structure
					-->
					<dict:fieldDescriptor>
						<dict:name>course.seasons</dict:name>
						<dict:desc>seasons offered</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="repeating"/>
						<dict:constraintRef bean="atp.types"/>
						<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.dynamic.attributes" key="attributes">
					<!--
						Services has this as an attributeInfoList but that is just a list
						of the attributeInfo substructure so I did't create the
						intermediary list sub-structure
					-->
					<dict:fieldDescriptor>
						<dict:name>course.dynamic.attributes</dict:name>
						<dict:desc>not used</dict:desc>
						<dict:dataType>complex</dict:dataType>

						<dict:objectStructure key="attributeInfo">
							<!-- List of key/value pairs, typically used for dynamic attributes. -->
							<dict:type key="(n/a)">
								<!-- Not applicable -->
								<dict:state key="(n/a)">
									<!-- Not applicable -->
								</dict:state>
							</dict:type>
						</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="repeating"/>
						<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.meta" key="metaInfo">
					<!-- must be empty on create but required on update -->
					<dict:fieldDescriptor>
						<dict:name>course.meta</dict:name>
						<dict:desc>audit trail info</dict:desc>
						<dict:dataType>complex</dict:dataType>

						<dict:objectStructure key="metaInfo">
							<!--
								Create and last update info for the structure. This is optional
								and treated as read only since the data is set by the internals
								of the service during maintenance operations.
							-->
							<dict:type key="(n/a)">
								<!-- Not applicable -->
								<dict:state key="(n/a)">
									<!-- Not applicable -->
								</dict:state>
							</dict:type>
						</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="kuali.meta.data"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.type" key="type">
					<!-- Requierd on the create but read-only after that -->
					<dict:fieldDescriptor>
						<dict:name>course.type</dict:name>
						<dict:desc>type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="kuali.type"/>
						<dict:constraintRef bean="lu.types"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>course.state</dict:name>
						<dict:desc>state</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="kuali.state"/>
						<dict:constraintRef bean="lu.states"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>

				<dict:field id="course.internalId" key="id">
					<!-- must be empty on create but required on update -->
					<dict:fieldDescriptor>
						<dict:name>course.internalId</dict:name>
						<dict:desc>internal id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="kuali.id"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="explore">
				<!-- Exploratory/Private scratch pad -->
				<!--
					Not sure if this is needed but UC mentions some ability for
					professors to create proposals within their own space
				-->
				<dict:fieldRef bean="course.no"/>
				<dict:fieldRef bean="course.alternateIdentifiers"/>
				<dict:fieldRef bean="course.campusLocation"/>
				<dict:fieldRef bean="course.desc"/>
				<dict:fieldRef bean="course.rationale"/>
				<dict:fieldRef bean="course.primaryAdminOrg"/>
				<dict:fieldRef bean="course.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.effectiveDate"/>
				<dict:fieldRef bean="course.expirationDate"/>
				<dict:fieldRef bean="course.contact.hours"/>
				<dict:fieldRef bean="course.duration"/>
				<dict:fieldRef bean="course.seasons"/>
				<dict:fieldRef bean="course.dynamic.attributes"/>
				<dict:fieldRef bean="course.meta"/>
				<dict:fieldRef bean="course.type"/>
				<dict:fieldRef bean="course.state"/>
				<dict:fieldRef bean="course.internalId"/>
			</dict:state>
			<dict:state key="draft">
				<!-- Entered as draft but not yet submitted -->

				<dict:field id="course.no.draft" key="officialIdentifier">
					<dict:fieldDescriptor>
						<dict:name>course.no</dict:name>
						<dict:desc>course no</dict:desc>
						<dict:dataType>complex</dict:dataType>

						<dict:objectStructure key="cluIdentifierInfo">
							<!--
								Detailed information about the human readable form of a CLU
								Identifier
							-->
							<dict:type key="kuali.lu.type.CreditCourse.identifier.official">
								<!-- This identifier holds the official identifier for this course -->
								<dict:state key="active">
									<!-- Identifier is active -->
									<!--
										TODO: Worry about states overlapping across xmlObjects. The
										lookup on thge Dictionary worksheet will grab the wrong one
									-->
									<dict:fieldRef bean="course.official.no"/>
									<dict:fieldRef bean="course.official.transcriptTitle"/>
									<dict:fieldRef bean="course.official.catalogTitle"/>
									<dict:fieldRef bean="course.official.level"/>
									<dict:fieldRef bean="course.official.subjectArea"/>
									<dict:fieldRef bean="course.official.numberPart"/>
									<dict:fieldRef bean="course.official.version"/>
									<dict:fieldRef bean="course.official.adminOrg"/>
									<dict:fieldRef bean="course.official.type"/>
									<dict:fieldRef bean="course.official.state"/>
									<dict:fieldRef bean="course.official.internalId"/>
								</dict:state>
								<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<dict:fieldRef bean="course.official.no"/>
									<dict:fieldRef bean="course.official.transcriptTitle"/>
									<dict:fieldRef bean="course.official.catalogTitle"/>
									<dict:fieldRef bean="course.official.level"/>
									<dict:fieldRef bean="course.official.subjectArea"/>
									<dict:fieldRef bean="course.official.numberPart"/>
									<dict:fieldRef bean="course.official.version"/>
									<dict:fieldRef bean="course.official.adminOrg"/>
									<dict:fieldRef bean="course.official.type"/>
									<dict:fieldRef bean="course.official.state"/>
									<dict:fieldRef bean="course.official.internalId"/>
								</dict:state>
							</dict:type>
							<dict:type key="kuali.lu.type.CreditCourse.identifier.cross-listed">
								<!--
									This identifier holds the cross-listed identifiers for this
									course
								-->
								<!-- (MIT's meaning of joint) -->
								<dict:state key="active">
									<!-- Identifier is active -->
									<!--
										TODO: Worry about states overlapping across xmlObjects. The
										lookup on thge Dictionary worksheet will grab the wrong one
									-->
								</dict:state>
								<dict:state key="inactive">
									<!-- Identifier is inactive -->
								</dict:state>
							</dict:type>
							<dict:type key="kuali.lu.type.CreditCourse.identifier.version">
								<!--
									This identifier holds the version information for courses that
									have multiple versions
								-->
								<!-- Variation -->
								<dict:state key="active">
									<!-- Identifier is active -->
									<!--
										TODO: Worry about states overlapping across xmlObjects. The
										lookup on thge Dictionary worksheet will grab the wrong one
									-->
								</dict:state>
								<dict:state key="inactive">
									<!-- Identifier is inactive -->
								</dict:state>
							</dict:type>
						</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.alternateIdentifiers.draft" key="alternateIdentifiers">
					<dict:fieldDescriptor>
						<dict:name>course.alternateIdentifiers</dict:name>
						<dict:desc>course alternate ids</dict:desc>
						<dict:dataType>complex</dict:dataType>

						<dict:objectStructure key="cluIdentifierInfo">
							<!--
								Detailed information about the human readable form of a CLU
								Identifier
							-->
							<dict:type key="kuali.lu.type.CreditCourse.identifier.official">
								<!-- This identifier holds the official identifier for this course -->
								<dict:state key="active">
									<!-- Identifier is active -->
									<!--
										TODO: Worry about states overlapping across xmlObjects. The
										lookup on thge Dictionary worksheet will grab the wrong one
									-->
								</dict:state>
								<dict:state key="inactive">
									<!-- Identifier is inactive -->
								</dict:state>
							</dict:type>
							<dict:type key="kuali.lu.type.CreditCourse.identifier.cross-listed">
								<!--
									This identifier holds the cross-listed identifiers for this
									course
								-->
								<!-- (MIT's meaning of joint) -->
								<dict:state key="active">
									<!-- Identifier is active -->
									<!--
										TODO: Worry about states overlapping across xmlObjects. The
										lookup on thge Dictionary worksheet will grab the wrong one
									-->
									<dict:fieldRef bean="course.cross-listed.no"/>
									<dict:fieldRef bean="course.cross-listed.transcriptTitle"/>
									<dict:fieldRef bean="course.cross-listed.catalogTitle"/>
									<dict:fieldRef bean="course.cross-listed.level"/>
									<dict:fieldRef bean="course.cross-listed.subjectArea"/>
									<dict:fieldRef bean="course.cross-listed.numberPart"/>
									<dict:fieldRef bean="course.cross-listed.version"/>
									<dict:fieldRef bean="course.cross-listed.adminOrg"/>
									<dict:fieldRef bean="course.cross-listed.type"/>
									<dict:fieldRef bean="course.cross-listed.state"/>
									<dict:fieldRef bean="course.cross-listed.internalId"/>
								</dict:state>
								<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<dict:fieldRef bean="course.cross-listed.no"/>
									<dict:fieldRef bean="course.cross-listed.transcriptTitle"/>
									<dict:fieldRef bean="course.cross-listed.catalogTitle"/>
									<dict:fieldRef bean="course.cross-listed.level"/>
									<dict:fieldRef bean="course.cross-listed.subjectArea"/>
									<dict:fieldRef bean="course.cross-listed.numberPart"/>
									<dict:fieldRef bean="course.cross-listed.version"/>
									<dict:fieldRef bean="course.cross-listed.adminOrg"/>
									<dict:fieldRef bean="course.cross-listed.type"/>
									<dict:fieldRef bean="course.cross-listed.state"/>
									<dict:fieldRef bean="course.cross-listed.internalId"/>
								</dict:state>
							</dict:type>
							<dict:type key="kuali.lu.type.CreditCourse.identifier.version">
								<!--
									This identifier holds the version information for courses that
									have multiple versions
								-->
								<!-- Variation -->
								<dict:state key="active">
									<!-- Identifier is active -->
									<!--
										TODO: Worry about states overlapping across xmlObjects. The
										lookup on thge Dictionary worksheet will grab the wrong one
									-->
									<dict:fieldRef bean="course.version.no"/>
									<dict:fieldRef bean="course.version.transcriptTitle"/>
									<dict:fieldRef bean="course.version.catalogTitle"/>
									<dict:fieldRef bean="course.version.level"/>
									<dict:fieldRef bean="course.version.subjectArea"/>
									<dict:fieldRef bean="course.version.numberPart"/>
									<dict:fieldRef bean="course.version.version"/>
									<dict:fieldRef bean="course.version.adminOrg"/>
									<dict:fieldRef bean="course.version.type"/>
									<dict:fieldRef bean="course.version.state"/>
									<dict:fieldRef bean="course.version.internalId"/>
								</dict:state>
								<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<dict:fieldRef bean="course.version.no"/>
									<dict:fieldRef bean="course.version.transcriptTitle"/>
									<dict:fieldRef bean="course.version.catalogTitle"/>
									<dict:fieldRef bean="course.version.level"/>
									<dict:fieldRef bean="course.version.subjectArea"/>
									<dict:fieldRef bean="course.version.numberPart"/>
									<dict:fieldRef bean="course.version.version"/>
									<dict:fieldRef bean="course.version.adminOrg"/>
									<dict:fieldRef bean="course.version.type"/>
									<dict:fieldRef bean="course.version.state"/>
									<dict:fieldRef bean="course.version.internalId"/>
								</dict:state>
							</dict:type>
						</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="repeating"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.campusLocation.draft" key="campusLocationInfo">
					<!--
						The message structure goes to another substructure but that just
						holds a string so I don't thnk that is needed and I changed the
						name to "Info" instead of "List" which is on the un-needed
						sub-structure
					-->
					<dict:fieldDescriptor>
						<dict:name>course.campusLocation</dict:name>
						<dict:desc>campus location</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="repeating"/>
						<dict:constraintRef bean="code"/>
						<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.desc.draft" key="desc">
					<dict:fieldDescriptor>
						<dict:name>course.desc</dict:name>
						<dict:desc>dscription</dict:desc>
						<dict:dataType>complex</dict:dataType>

						<dict:objectStructure key="richTextInfo">
							<!--
								Complex type supporting both a plain text and formatted version
								of a string.
							-->
							<dict:type key="(n/a)">
								<!-- Not applicable -->
								<dict:state key="(n/a)">
									<!-- Not applicable -->
								</dict:state>
							</dict:type>
						</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.rationale.draft" key="marketingDesc">
					<!--
						Not used in KRU but wanted an example of multiple RichText fields
					-->
					<dict:fieldDescriptor>
						<dict:name>course.rationale</dict:name>
						<dict:desc>rationale</dict:desc>
						<dict:dataType>complex</dict:dataType>

						<dict:objectStructure key="richTextInfo">
							<!--
								Complex type supporting both a plain text and formatted version
								of a string.
							-->
							<dict:type key="(n/a)">
								<!-- Not applicable -->
								<dict:state key="(n/a)">
									<!-- Not applicable -->
								</dict:state>
							</dict:type>
						</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.primaryAdminOrg.draft" key="primaryAdminOrg">
					<!--
						Services has this on it's own structure called AdminOrgInfo that
						allows for dynamic fields to be attached to the org but I am not
						modeling that right now so I don't have to go to 3 levels.
					-->
					<dict:fieldDescriptor>
						<dict:name>course.primaryAdminOrg</dict:name>
						<dict:desc>department</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="related.orgId"/>
						<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>

				<dict:field id="course.alternateAdminOrgs.draft" key="alternateAdminOrgs">
					<!--
						Services has this on it's own structure called AdminOrgInfo that
						allows for dynamic fields to be attached to the org but I am not
						modeling that right now so I don't have to go to 3 levels.
					-->
					<dict:fieldDescriptor>
						<dict:name>course.alternateAdminOrgs</dict:name>
						<dict:desc>not used</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="repeating"/>
						<dict:constraintRef bean="related.orgId"/>
						<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.effectiveDate.draft" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>course.effectiveDate</dict:name>
						<dict:desc>first date can be offered</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="date"/>
						<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.expirationDate.draft" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>course.expirationDate</dict:name>
						<dict:desc>last date can be offerred</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="date"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.contact.hours.draft" key="intensity">
					<dict:fieldDescriptor>
						<dict:name>course.contact.hours</dict:name>
						<dict:desc>contact hours</dict:desc>
						<dict:dataType>complex</dict:dataType>

						<dict:objectStructure key="amountInfo">
							<!--
								Detailed information about an amount including both the type of
								units and the quantity.
							-->
							<dict:type key="(n/a)">
								<!-- Not applicable -->
								<dict:state key="(n/a)">
									<!-- Not applicable -->
								</dict:state>
							</dict:type>
						</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.duration.draft" key="stdDuration">
					<dict:fieldDescriptor>
						<dict:name>course.duration</dict:name>
						<dict:desc>duration</dict:desc>
						<dict:dataType>complex</dict:dataType>

						<dict:objectStructure key="timeAmountInfo">
							<!--
								Detailed information about an amount of time including both the
								type of units and the quantity.
							-->
							<dict:type key="(n/a)">
								<!-- Not applicable -->
								<dict:state key="(n/a)">
									<!-- Not applicable -->
								</dict:state>
							</dict:type>
						</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.seasons.draft" key="offeredAtpTypes">
					<!--
						Services has this as an atpKeyList but that is just a list of
						Strings so I didn't create the sub-structure
					-->
					<dict:fieldDescriptor>
						<dict:name>course.seasons</dict:name>
						<dict:desc>seasons offered</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="repeating"/>
						<dict:constraintRef bean="atp.types"/>
						<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.dynamic.attributes.draft" key="attributes">
					<!--
						Services has this as an attributeInfoList but that is just a list
						of the attributeInfo substructure so I did't create the
						intermediary list sub-structure
					-->
					<dict:fieldDescriptor>
						<dict:name>course.dynamic.attributes</dict:name>
						<dict:desc>not used</dict:desc>
						<dict:dataType>complex</dict:dataType>

						<dict:objectStructure key="attributeInfo">
							<!-- List of key/value pairs, typically used for dynamic attributes. -->
							<dict:type key="(n/a)">
								<!-- Not applicable -->
								<dict:state key="(n/a)">
									<!-- Not applicable -->
								</dict:state>
							</dict:type>
						</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="repeating"/>
						<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.meta.draft" key="metaInfo">
					<!-- must be empty on create but required on update -->
					<dict:fieldDescriptor>
						<dict:name>course.meta</dict:name>
						<dict:desc>audit trail info</dict:desc>
						<dict:dataType>complex</dict:dataType>

						<dict:objectStructure key="metaInfo">
							<!--
								Create and last update info for the structure. This is optional
								and treated as read only since the data is set by the internals
								of the service during maintenance operations.
							-->
							<dict:type key="(n/a)">
								<!-- Not applicable -->
								<dict:state key="(n/a)">
									<!-- Not applicable -->
								</dict:state>
							</dict:type>
						</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="kuali.meta.data"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.type.draft" key="type">
					<!-- Requierd on the create but read-only after that -->
					<dict:fieldDescriptor>
						<dict:name>course.type</dict:name>
						<dict:desc>type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="kuali.type"/>
						<dict:constraintRef bean="lu.types"/>
					</dict:constraintDescriptor>
				</dict:field>

				<dict:field id="course.state.draft" key="state">
					<dict:fieldDescriptor>
						<dict:name>course.state</dict:name>
						<dict:desc>state</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="kuali.state"/>
						<dict:constraintRef bean="lu.states"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>

				<dict:field id="course.internalId.draft" key="id">
					<!-- must be empty on create but required on update -->
					<dict:fieldDescriptor>
						<dict:name>course.internalId</dict:name>
						<dict:desc>internal id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
						<dict:constraintRef bean="kuali.id"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="submitted">
				<!-- Submitted but not yet approved -->
				<dict:fieldRef bean="course.no"/>
				<dict:fieldRef bean="course.alternateIdentifiers"/>
				<dict:fieldRef bean="course.campusLocation"/>
				<dict:fieldRef bean="course.desc"/>
				<dict:fieldRef bean="course.rationale"/>
				<dict:fieldRef bean="course.primaryAdminOrg"/>
				<dict:fieldRef bean="course.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.effectiveDate"/>
				<dict:fieldRef bean="course.expirationDate"/>
				<dict:fieldRef bean="course.contact.hours"/>
				<dict:fieldRef bean="course.duration"/>
				<dict:fieldRef bean="course.seasons"/>
				<dict:fieldRef bean="course.dynamic.attributes"/>
				<dict:fieldRef bean="course.meta"/>
				<dict:fieldRef bean="course.type"/>
				<dict:fieldRef bean="course.state"/>
				<dict:fieldRef bean="course.internalId"/>
			</dict:state>
			<dict:state key="withdrawn">
				<!-- Withdrawn (anytime before activated) -->
				<dict:fieldRef bean="course.no"/>
				<dict:fieldRef bean="course.alternateIdentifiers"/>
				<dict:fieldRef bean="course.campusLocation"/>
				<dict:fieldRef bean="course.desc"/>
				<dict:fieldRef bean="course.rationale"/>
				<dict:fieldRef bean="course.primaryAdminOrg"/>
				<dict:fieldRef bean="course.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.effectiveDate"/>
				<dict:fieldRef bean="course.expirationDate"/>
				<dict:fieldRef bean="course.contact.hours"/>
				<dict:fieldRef bean="course.duration"/>
				<dict:fieldRef bean="course.seasons"/>
				<dict:fieldRef bean="course.dynamic.attributes"/>
				<dict:fieldRef bean="course.meta"/>
				<dict:fieldRef bean="course.type"/>
				<dict:fieldRef bean="course.state"/>
				<dict:fieldRef bean="course.internalId"/>
			</dict:state>
			<dict:state key="approved">
				<!-- Approved -->
				<dict:fieldRef bean="course.no"/>
				<dict:fieldRef bean="course.alternateIdentifiers"/>
				<dict:fieldRef bean="course.campusLocation"/>
				<dict:fieldRef bean="course.desc"/>
				<dict:fieldRef bean="course.rationale"/>
				<dict:fieldRef bean="course.primaryAdminOrg"/>
				<dict:fieldRef bean="course.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.effectiveDate"/>
				<dict:fieldRef bean="course.expirationDate"/>
				<dict:fieldRef bean="course.contact.hours"/>
				<dict:fieldRef bean="course.duration"/>
				<dict:fieldRef bean="course.seasons"/>
				<dict:fieldRef bean="course.dynamic.attributes"/>
				<dict:fieldRef bean="course.meta"/>
				<dict:fieldRef bean="course.type"/>
				<dict:fieldRef bean="course.state"/>
				<dict:fieldRef bean="course.internalId"/>
			</dict:state>
			<dict:state key="not">
				<!-- Not approved -->
				<!--
					Do we need here some indication of why it was not approved? I.e.
					disapproved vs. not acted on because submitted too late, etc.
				-->
				<dict:fieldRef bean="course.no"/>
				<dict:fieldRef bean="course.alternateIdentifiers"/>
				<dict:fieldRef bean="course.campusLocation"/>
				<dict:fieldRef bean="course.desc"/>
				<dict:fieldRef bean="course.rationale"/>
				<dict:fieldRef bean="course.primaryAdminOrg"/>
				<dict:fieldRef bean="course.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.effectiveDate"/>
				<dict:fieldRef bean="course.expirationDate"/>
				<dict:fieldRef bean="course.contact.hours"/>
				<dict:fieldRef bean="course.duration"/>
				<dict:fieldRef bean="course.seasons"/>
				<dict:fieldRef bean="course.dynamic.attributes"/>
				<dict:fieldRef bean="course.meta"/>
				<dict:fieldRef bean="course.type"/>
				<dict:fieldRef bean="course.state"/>
				<dict:fieldRef bean="course.internalId"/>
			</dict:state>
			<dict:state key="activated">
				<!-- Activated and ready to be published -->
				<dict:fieldRef bean="course.no"/>
				<dict:fieldRef bean="course.alternateIdentifiers"/>
				<dict:fieldRef bean="course.campusLocation"/>
				<dict:fieldRef bean="course.desc"/>
				<dict:fieldRef bean="course.rationale"/>
				<dict:fieldRef bean="course.primaryAdminOrg"/>
				<dict:fieldRef bean="course.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.effectiveDate"/>
				<dict:fieldRef bean="course.expirationDate"/>
				<dict:fieldRef bean="course.contact.hours"/>
				<dict:fieldRef bean="course.duration"/>
				<dict:fieldRef bean="course.seasons"/>
				<dict:fieldRef bean="course.dynamic.attributes"/>
				<dict:fieldRef bean="course.meta"/>
				<dict:fieldRef bean="course.type"/>
				<dict:fieldRef bean="course.state"/>
				<dict:fieldRef bean="course.internalId"/>
			</dict:state>
			<dict:state key="retired">
				<!-- Retired/No longer active -->
				<!--
					Do we need/want to differentiate here between retiring a course
					simply because it will no longer be taught and retiring a version
					of a course because it has been superceded by a newer version.
				-->
				<dict:fieldRef bean="course.no"/>
				<dict:fieldRef bean="course.alternateIdentifiers"/>
				<dict:fieldRef bean="course.campusLocation"/>
				<dict:fieldRef bean="course.desc"/>
				<dict:fieldRef bean="course.rationale"/>
				<dict:fieldRef bean="course.primaryAdminOrg"/>
				<dict:fieldRef bean="course.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.effectiveDate"/>
				<dict:fieldRef bean="course.expirationDate"/>
				<dict:fieldRef bean="course.contact.hours"/>
				<dict:fieldRef bean="course.duration"/>
				<dict:fieldRef bean="course.seasons"/>
				<dict:fieldRef bean="course.dynamic.attributes"/>
				<dict:fieldRef bean="course.meta"/>
				<dict:fieldRef bean="course.type"/>
				<dict:fieldRef bean="course.state"/>
				<dict:fieldRef bean="course.internalId"/>
			</dict:state>
		</dict:type>
	</dict:objectStructure>
</beans>
